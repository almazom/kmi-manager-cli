Project Analysis: KMI Manager CLI
Generated: 2026-01-29 21:36:42 MSK
Analyst: Peter (Senior Code Archaeologist)
Location: Mom's Basement Command Center
Cats Present During Analysis: 1
Analysis Duration: 0 seconds

PETER'S INITIAL REACTION
*Adjusts glasses* The codebase is a tidy little cat condo: compact, well-labeled rooms, and a clear path from CLI to proxy to upstream. Sweet spaghetti code? Not here. The structure is modest and readable, like a well-behaved clowder of cats sharing a feeding schedule.

1. EXECUTIVE SUMMARY
- Purpose: Provide a local CLI (kmi) that manages multiple Kimi API keys, supports manual and auto rotation, and provides traceability.
- Solution: Typer-based CLI + FastAPI proxy + local state/logging/trace JSONL.
- Users: Developers/operators using Kimi CLI who need key rotation and auditing.
- Scale: Single-user local tool; supports 20+ keys by design.
- Status: Early implementation (version 0.1.0) with unit tests and SDD docs.
- Peter's Take: It behaves like a clowder of cats: independent keys, coordinated rotation.

2. ARCHITECTURAL OVERVIEW
System Architecture
- CLI entrypoint: kmi_manager_cli.cli (Typer) orchestrates commands.
- Core modules: config, keys, rotation, health, state, trace, ui, logging.
- Proxy: FastAPI app forwards requests to upstream with selected key.
- Storage: state.json, trace.jsonl, logs/kmi.log.

ARCHITECTURE DIAGRAM
+---------------------------+
| CLI (Typer)               |
| - kmi --rotate            |
| - kmi --auto_rotate       |
| - kmi --trace             |
| - kmi proxy               |
+-------------+-------------+
              |
              v
+---------------------------+
| Core Logic                |
| config | keys | rotation  |
| health | state | trace    |
| ui     | logging           |
+------+------+-------------+
       |      |
       |      v
       |   Local Files
       |   - state.json
       |   - trace.jsonl
       |   - logs/kmi.log
       |
       v
+---------------------------+
| Local Proxy (FastAPI)     |
| httpx -> upstream         |
+-------------+-------------+
              |
              v
+---------------------------+
| Kimi API (upstream)       |
| /chat/completions         |
| /models /usages           |
+---------------------------+

Technology Stack
- Python >= 3.8
- CLI: Typer, Rich
- Proxy/API: FastAPI, Uvicorn, httpx
- Config: python-dotenv
- Tests: pytest, pytest-asyncio

Design Patterns Identified
- Configuration object (Config dataclass)
- Registry pattern for keys (Registry)
- Functional scoring for rotation and health
- Append-only trace log (JSONL)

3. DATA FLOW VISUALIZATION
Manual rotate flow:
User -> kmi --rotate
  -> load_config (.env)
  -> load_auths_dir (_auths)
  -> load_state (~/.kmi/state.json)
  -> get_health_map (/usages)
  -> rotate_manual (most resourceful)
  -> save_state
  -> render dashboard

Proxy request flow:
Client -> http://host:port/base_path/...
  -> FastAPI route
  -> select_key_for_request (round-robin if auto)
  -> inject Authorization: Bearer <key>
  -> httpx request to upstream
  -> record_request + mark_exhausted (on 403/429)
  -> append_trace (trace.jsonl)
  -> response to client

4. KEY BUSINESS WORKFLOWS
Primary User Journeys
- Manual rotate: selects most resourceful key and shows dashboard.
- Auto rotate: round-robin per request via proxy.
- Trace: live TUI for per-request routing with confidence metric.

Core Features
- Key registry from _auths and optional ~/.kimi/config.toml
- Health scoring via /usages
- Round-robin selection with cooldown for 403/429
- JSONL trace with MSK timestamps

5. TECHNICAL IMPLEMENTATION
Code Organization
- Structure: single package under src/kmi_manager_cli
- Layers: CLI -> Core logic -> Proxy -> Upstream
- Principles: small modules, explicit state handling

Directory Structure
project-root/
|- README.md
|- pyproject.toml
|- sitecustomize.py
|- kmi_manager_cli/        (shim package for src path)
|- src/
|  `- kmi_manager_cli/
|     |- cli.py
|     |- config.py
|     |- keys.py
|     |- rotation.py
|     |- health.py
|     |- proxy.py
|     |- trace.py
|     |- trace_tui.py
|     |- ui.py
|     |- state.py
|     |- logging.py
|     |- auth_accounts.py
|     `- errors.py
|- tests/
|  |- test_cli_help.py
|  |- test_cli_rotate.py
|  |- test_proxy.py
|  |- test_trace.py
|  |- test_health.py
|  |- test_rotation.py
|  |- test_config.py
|  |- test_keys.py
|  `- test_state.py
`- docs/
   `- sdd/kmi-rotation-sdd/

Key Abstractions
- Config: central env configuration
- Registry: ordered, masked key inventory
- State: persistent rotation index and error counters
- HealthInfo: derived status per key

6. DATABASE SCHEMA
No external database. Local persistence uses JSON files:
- ~/.kmi/state.json
  {"active_index": int, "rotation_index": int, "auto_rotate": bool, "keys": {label: {last_used, request_count, error_401, error_403, error_429, error_5xx, exhausted_until}}}
- ~/.kmi/trace/trace.jsonl (append-only events)

7. DEPLOYMENT ARCHITECTURE
+------------------------------+
| Developer machine            |
| - kmi CLI                    |
| - uvicorn proxy              |
| - local state/logs           |
+--------------+---------------+
               |
               | HTTPS
               v
+------------------------------+
| Kimi API (api.kimi.com)      |
| chat, models, usages         |
+------------------------------+

8. QUICK START GUIDE
Prerequisites
- Python 3.8+
- pip

Installation
- pip install -e .

Development Setup
- kmi --help
- kmi --rotate
- kmi proxy

Tests
- pytest

9. CRITICAL INTEGRATION POINTS
External Dependencies
- Upstream Kimi API base URL (default https://api.kimi.com/coding/v1)
- /usages endpoint for health scoring

Internal Component Communication
- CLI loads config -> registry -> state -> rotation/health -> UI
- Proxy writes to state + trace + logs

10. OPERATIONAL CONSIDERATIONS
- Logging: JSON logs at ~/.kmi/logs/kmi.log
- Trace: JSONL at ~/.kmi/trace/trace.jsonl
- Observability: confidence metric from recent trace window

11. VERSION CONTROL INSIGHTS
- Repo just initialized, no commits yet.
- Uncommitted files present (working tree not clean).
- No branches or history to analyze.

12. EVOLUTION PATH & RECOMMENDATIONS
- Add file locking for state.json and trace.jsonl to avoid concurrent write issues (two cats, one food bowl).
- Add integration tests for proxy + upstream error paths.
- Fix UI health dashboard variable naming (reset_line) to avoid runtime errors.
- Import Account in cli.py for --health path.
- Document setup and .env examples in root README.

13. CRITICAL FINDINGS & RISKS
Security Considerations
- Secrets are externalized, good. Risk: local state/log files are plaintext; consider permissions.

Architectural Concerns
- Concurrency: state.json is updated without locking; parallel requests may race.
- UI dashboard contains a NameError risk (reset_line not defined).
- cli.py references Account without import in --health path.

Peter's Honest Opinion
*Leans back in chair* This is clean for a first pass. It is like a small catio: safe, purposeful, but it needs a sturdier latch before you let many cats in at once.

QUICK REFERENCE
Key Files and Locations
- Entry Point: src/kmi_manager_cli/cli.py
- Configuration: src/kmi_manager_cli/config.py
- Core Business Logic: src/kmi_manager_cli/rotation.py
- Proxy: src/kmi_manager_cli/proxy.py
- Tests: tests/
- Documentation: docs/sdd/kmi-rotation-sdd/

Common Development Tasks
- Run locally: kmi --help
- Run tests: pytest
- Build: python -m build (optional)
- Deploy: local install via pip install -e .

PETER'S FINAL THOUGHTS
*Adjusts glasses* In my 15 years of code spelunking, this one is pleasantly organized. The proxy is like a cat door: requests come in, keys slip out, and the upstream gets fed. Add a bit of locking and error-path polish, and this clowder will purr.

Stay curious,
Peter
