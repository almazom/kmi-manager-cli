Project Analysis: KMI Manager CLI
Generated: 2026-01-31 07:12:11 UTC
Analyst: Peter (Senior Code Archaeologist)
Location: Mom's Basement Command Center
Cats Present During Analysis: 3
Analysis Duration: 0 seconds

PETER'S INITIAL REACTION
*Adjusts glasses* The codebase is a tidy cat condo: small, well-labeled rooms, and clear walkways from CLI to proxy to upstream. In my 15 years of code spelunking, this is the kind of compact system that purrs when fed the right inputs. Oh, Mr. Whiskers, not now... I'm reading the proxy module.

1. EXECUTIVE SUMMARY
- Purpose: Manage multiple Kimi API keys with manual rotation, auto-rotation via local proxy, and audit/trace visibility.
- Solution: Typer CLI + FastAPI proxy + local file state/log/trace with health scoring from /usages.
- Users: Developers/operators running local Kimi CLI workflows who need key pooling and observability.
- Scale: Single-host tool with many keys; optimized for local ops and dev environments.
- Status: Python package (v0.1.0), SDD documentation, and CI tests.
- Peter's take: Think of it like a cat door that only opens for the right key, then logs every paw print.

2. ARCHITECTURAL OVERVIEW
System Architecture
- CLI entrypoint: src/kmi_manager_cli/cli.py (Typer) orchestrates commands and modes.
- Core modules: config, auth_accounts, keys, rotation, health, state, trace, ui, logging, audit.
- Proxy: FastAPI app forwards requests to upstream with selected key and rate limits.
- Storage: _auths/*, ~/.kmi/state.json, ~/.kmi/trace/trace.jsonl, ~/.kmi/logs/kmi.log, ~/.kimi/config.toml.

ARCHITECTURE DIAGRAM
+---------------------------+
| User / Terminal           |
+------------+--------------+
             |
             v
+---------------------------+
| kmi CLI (Typer)            |
| - --rotate/--auto_rotate   |
| - trace / health / status  |
| - proxy / e2e              |
+------------+--------------+
             |
             v
+---------------------------+           +---------------------------+
| Core Logic                |<----------| Local Filesystem          |
| config/keys/rotation      |           | _auths/*.env|toml|json     |
| health/state/trace/ui     |           | ~/.kmi/state.json          |
| logging/audit/security    |           | ~/.kmi/trace/trace.jsonl   |
+------------+--------------+           | ~/.kmi/logs/kmi.log        |
             |                          | ~/.kimi/config.toml        |
             v                          +---------------------------+
+---------------------------+
| FastAPI Proxy             |
| /kmi-rotor/v1/{path}       |
| auth + rate limit + trace |
+------------+--------------+
             |
             v
+---------------------------+
| Kimi API (Upstream)        |
| /models /chat/completions |
| /usages                    |
+---------------------------+

Technology Stack
- Python >= 3.9
- CLI: Typer, Rich
- Proxy/API: FastAPI, Uvicorn, httpx
- Config: python-dotenv
- Tests: pytest, pytest-asyncio

Design Patterns Identified
- Configuration object (Config dataclass)
- Registry pattern for keys (Registry + KeyRecord)
- File locking + atomic writes for state/trace
- Debounced state writer, queued trace writer
- Global and per-key rate limiting

3. DATA FLOW VISUALIZATION
Manual rotate flow
User -> kmi --rotate
  -> load_config (.env)
  -> load_auths_dir (_auths)
  -> load_state (~/.kmi/state.json)
  -> get_health_map (/usages)
  -> rotate_manual (most resourceful)
  -> save_state + optional ~/.kimi/config.toml copy
  -> render rotation dashboard

Proxy request flow
Client -> http://host:port/base_path/...
  -> FastAPI route
  -> authorize (proxy token) + rate limit
  -> select_key_for_request (round-robin if auto)
  -> inject Authorization: Bearer <key>
  -> httpx request to upstream
  -> record_request + mark_exhausted on 403/429
  -> append_trace (trace.jsonl) + JSON logs
  -> response to client

E2E flow (optional)
User -> kmi e2e
  -> ensure proxy running
  -> send batches via proxy
  -> read trace.jsonl
  -> compute distribution + confidence

4. KEY BUSINESS WORKFLOWS
Primary User Journeys
- Manual rotate: selects most resourceful key and shows dashboard.
- Auto rotate: round-robin per request via proxy (guarded by KMI_AUTO_ROTATE_ALLOWED).
- Proxy run: forward upstream requests with key selection, logging, and tracing.
- Trace: live TUI showing recent request routing and confidence.
- Health: dashboard of all keys or current key only.
- E2E: confidence check on round-robin distribution.

Core Features
- Multi-format auth intake: _auths/*.env, *.toml, *.json (+ .json.bak) with label normalization.
- Health scoring: /usages parsing with status (healthy/warn/blocked).
- Rotation safety: cooldown on 403/429 and 401 blocks; tie handling via KMI_ROTATE_ON_TIE.
- Traceability: JSONL trace with prompt hints and confidence scoring.
- Auditing: audit_event logs for auto-rotate toggles and config writes.

5. TECHNICAL IMPLEMENTATION
Code Organization
- src/kmi_manager_cli: CLI, config, proxy, rotation, health, trace, UI, logging, security.
- tests/: unit and scenario coverage for CLI, rotation, proxy, trace, config.
- docs/: SDD requirements and review library.

Directory Structure (abridged)
project-root/
├── README.md
├── pyproject.toml
├── .github/workflows/pytest.yml
├── src/kmi_manager_cli/
│   ├── cli.py
│   ├── config.py
│   ├── auth_accounts.py
│   ├── keys.py
│   ├── rotation.py
│   ├── health.py
│   ├── proxy.py
│   ├── state.py
│   ├── trace.py
│   ├── trace_tui.py
│   ├── ui.py
│   ├── logging.py
│   ├── security.py
│   └── audit.py
├── tests/
└── docs/sdd/

Security and Resilience
- Enforces HTTPS upstream base URL and optional upstream allowlist.
- Remote proxy binding requires explicit allow + token + TLS checks.
- File locks + atomic writes protect state.json and trace.jsonl.
- Trace queue drops entries if saturated, with logging.

6. DATABASE SCHEMA
No external database. Local persistence uses JSON files.

state.json
{
  "schema_version": 1,
  "active_index": 0,
  "rotation_index": 0,
  "auto_rotate": false,
  "keys": {
    "label": {
      "last_used": "2026-01-31T00:00:00Z",
      "request_count": 12,
      "error_401": 0,
      "error_403": 0,
      "error_429": 1,
      "error_5xx": 0,
      "exhausted_until": "2026-01-31T01:00:00Z"
    }
  }
}

trace.jsonl (append-only)
{"ts":"2026-01-31 00:00:00 +0000","request_id":"...","key_label":"alpha","endpoint":"/models","status":200}

7. DEPLOYMENT ARCHITECTURE
Local-first CLI with optional proxy server:

Developer Machine
  - kmi CLI
  - FastAPI proxy (uvicorn)
  - Local state/logs/trace
        |
        v
  Kimi API (upstream)

Remote proxy usage is possible only when explicitly enabled and secured (TLS + token).

8. QUICK START GUIDE
Prerequisites
- Python 3.9+
- pip

Install
- pip install -e .

Configure
- Create _auths/*.env with KMI_API_KEY and KMI_KEY_LABEL
- Optional .env for proxy settings and rotation behavior

Run
- kmi --help
- kmi --rotate
- kmi proxy
- kmi trace
- kmi e2e

Tests
- pytest -q

9. CRITICAL INTEGRATION POINTS
External Dependencies
- Kimi API upstream: /chat/completions, /models, /usages
- Local Kimi CLI config: ~/.kimi/config.toml
- Filesystem: _auths directory + KMI_STATE_DIR

Internal Component Communication
- CLI -> core modules via direct calls
- Proxy -> state/logging/trace through shared State and writers
- Audit events emitted to JSON logs

10. OPERATIONAL CONSIDERATIONS
- Logging: JSON logs with rotation in ~/.kmi/logs/kmi.log
- Trace retention: configurable size and backup count
- Rate limiting: global and per-key via env vars
- Dry-run default: upstream requests simulated unless KMI_DRY_RUN=0
- Locale/timezone: KMI_LOCALE and KMI_TIMEZONE for summaries and timestamps

11. VERSION CONTROL INSIGHTS
- Branch: master
- Commits: 62 total (HEAD 5e8f409)
- Recent commit: 5e8f409 Run e2e on auto-rotate with env toggle
- CI: .github/workflows/pytest.yml (Python 3.9-3.11)
- Uncommitted changes: 9 files (see git status)

12. EVOLUTION PATH & RECOMMENDATIONS
- Add packaging guidance (pipx / release artifacts) for user installs.
- Expand CI to include lint/type checks (ruff, mypy).
- Add integration tests for proxy auth token, TLS requirements, and allowlist.
- Document log/trace retention and privacy implications.
- Consider pluggable upstreams if multi-provider support becomes a goal.

13. CRITICAL FINDINGS & RISKS
Security Considerations
- Local state/log/trace are plaintext; relies on filesystem permissions. Warnings exist but no enforcement.
- Remote proxy can be exposed if TLS requirements are overridden; treat KMI_PROXY_REQUIRE_TLS=0 as high risk.

Operational Risks
- Auto-rotation and E2E traffic should comply with provider ToS and rate limits.
- Trace queue can drop entries under extreme load (logged but still a gap).

Peter's Honest Opinion
*Leans back in chair* This is a small but disciplined cat: compact, sharp, and mostly house-trained. Keep it fed with tests and clear docs, and it will behave even when the cats sprint at 2am.

QUICK REFERENCE
Key Files and Locations
- Entry Point: src/kmi_manager_cli/cli.py
- Configuration: src/kmi_manager_cli/config.py
- Core Rotation: src/kmi_manager_cli/rotation.py
- Proxy: src/kmi_manager_cli/proxy.py
- State/Trace: src/kmi_manager_cli/state.py, src/kmi_manager_cli/trace.py
- Docs: docs/sdd/kmi-rotation-sdd/

Common Development Tasks
- Run locally: kmi --help
- Rotate: kmi --rotate
- Run proxy: kmi proxy
- Run tests: pytest -q

PETER'S FINAL THOUGHTS
*Adjusts glasses* Time to draw this out. The design is clean, the paths are clear, and the edges are mostly protected. With a little extra guardrail polish, this catio is ready for more visitors.
