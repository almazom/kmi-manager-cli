# Project Analysis: KMI Manager CLI
Generated: 2026-01-29 22:12:55 MSK
Analyst: Peter (Senior Code Archaeologist)
Location: Mom's Basement Command Center
Cats Present During Analysis: 3
Analysis Duration: 0 seconds

## PETER'S INITIAL REACTION
*Adjusts glasses* The codebase is a tidy cat condo: small, well-labeled rooms, and clear walkways from CLI to proxy to upstream. It's not spaghetti code; it's more like a clowder of cats sharing a clean feeding schedule. If a system can purr, this one nearly does.

## 1. EXECUTIVE SUMMARY
- Purpose: Provide a local CLI (kmi) that manages multiple Kimi API keys, supports manual and auto rotation, and provides traceability.
- Solution: Typer-based CLI + FastAPI proxy + local state/logging/trace JSONL.
- Users: Developers/operators using Kimi CLI who need key rotation, auditability, and health visibility.
- Scale: Single-user local tool; designed to support 20+ keys.
- Status: Active implementation (version 0.1.0) with tests and SDD docs.
- Peter's Take: It behaves like a cat door: lightweight, local, and only opens when the right key shows up.

## 2. ARCHITECTURAL OVERVIEW
### System Architecture
- CLI entrypoint: src/kmi_manager_cli/cli.py (Typer) orchestrates commands.
- Core modules: config, keys, rotation, health, state, trace, ui, logging.
- Proxy: FastAPI app forwards requests to upstream with selected key.
- Storage: state.json, trace.jsonl, logs/kmi.log under KMI_STATE_DIR.

### ARCHITECTURE DIAGRAM
+-------------------------------+
| CLI (Typer)                   |
| - kmi --rotate/--auto_rotate  |
| - kmi --trace/--all/--health  |
| - kmi proxy                   |
+---------------+---------------+
                |
                v
+-------------------------------+
| Core Logic (src/kmi_manager_cli) |
| config | keys | rotation      |
| health | state | trace | ui   |
| logging | auth_accounts       |
+-------+-----------------------+
        |                                 |                                  v                           v
+-------------------------------+  +--------------------------+
| Local Filesystem              |  | Local Proxy (FastAPI)    |
| - _auths/*.env                |  | /kmi-rotor/v1/{path}     |
| - ~/.kimi/config.toml         |  | httpx -> upstream        |
| - ~/.kmi/state.json           |  +--------------+-----------+
| - ~/.kmi/trace/trace.jsonl    |                 |
| - ~/.kmi/logs/kmi.log         |                 v
+-------------------------------+  +--------------------------+
                                   | Kimi API (Upstream)      |
                                   | /chat/completions        |
                                   | /models /usages          |
                                   +--------------------------+

### Technology Stack
- Python >= 3.8
- CLI: Typer, Rich
- Proxy/API: FastAPI, Uvicorn, httpx
- Config: python-dotenv
- Tests: pytest, pytest-asyncio

### Design Patterns Identified
- Configuration object (Config dataclass)
- Registry pattern for keys (Registry)
- Functional scoring for rotation and health
- Append-only trace log (JSONL)

## 3. DATA FLOW VISUALIZATION
### Manual rotate flow
User -> kmi --rotate
  -> load_config (.env)
  -> load_auths_dir (_auths)
  -> load_state (~/.kmi/state.json)
  -> get_health_map (/usages)
  -> rotate_manual (most resourceful)
  -> save_state
  -> render dashboard

### Proxy request flow
Client -> http://host:port/base_path/...
  -> FastAPI route
  -> authorize + rate limit
  -> select_key_for_request (round-robin if auto)
  -> inject Authorization: Bearer <key>
  -> httpx request to upstream
  -> record_request + mark_exhausted (on 403/429)
  -> append_trace (trace.jsonl)
  -> response to client

## 4. KEY BUSINESS WORKFLOWS
### Primary User Journeys
- Manual rotate: selects most resourceful key and shows dashboard.
- Auto rotate: round-robin per request via proxy.
- Trace: live TUI for per-request routing with confidence metric.
- Health: dashboard for all keys or current key only.

### Core Features
- Key registry from _auths and optional ~/.kimi/config.toml
- Health scoring via /usages endpoint
- Round-robin selection with cooldown for 403/429
- JSONL trace with MSK timestamps

## 5. TECHNICAL IMPLEMENTATION
### Code Organization
- Structure: single package under src/kmi_manager_cli
- Layers: CLI -> Core logic -> Proxy -> Upstream
- Principles: small modules, explicit state handling, file locks

### Directory Structure
project-root/
├── README.md
├── pyproject.toml
├── sitecustomize.py
├── src/
│   └── kmi_manager_cli/
│       ├── cli.py
│       ├── config.py
│       ├── keys.py
│       ├── rotation.py
│       ├── health.py
│       ├── proxy.py
│       ├── state.py
│       ├── trace.py
│       ├── trace_tui.py
│       ├── ui.py
│       └── logging.py
├── tests/
└── docs/
    └── sdd/

## 6. DATABASE SCHEMA
No external database. State is file-based:

state.json
{
  "active_index": 0,
  "rotation_index": 0,
  "auto_rotate": false,
  "keys": {
    "label": {
      "last_used": "2026-01-29T...Z",
      "request_count": 12,
      "error_401": 0,
      "error_403": 0,
      "error_429": 1,
      "error_5xx": 0,
      "exhausted_until": "2026-01-29T...Z"
    }
  }
}

trace.jsonl (append-only)
{"ts_msk":"...","request_id":"...","key_label":"...","endpoint":"...","status":200,"latency_ms":12}

## 7. DEPLOYMENT ARCHITECTURE
Local-first CLI with optional proxy server:

Developer Machine
  ├─ kmi CLI
  ├─ FastAPI proxy (uvicorn)
  └─ Local state/logs
         |
         v
     Kimi API (upstream)

Remote proxy binding is guarded by KMI_PROXY_ALLOW_REMOTE=1 and KMI_PROXY_TOKEN.

## 8. QUICK START GUIDE
Prerequisites
- python3 >= 3.8
- pip

Installation
- pip install -e .

Configuration
- Create _auths/*.env with KMI_API_KEY and KMI_KEY_LABEL
- Optional .env for KMI_PROXY_LISTEN, KMI_PROXY_BASE_PATH, KMI_STATE_DIR

Common Commands
- kmi --help
- kmi --rotate
- kmi --auto_rotate
- kmi --trace
- kmi --all
- kmi proxy

Tests
- pytest

## 9. CRITICAL INTEGRATION POINTS
External Dependencies
- Kimi API upstream: /chat/completions, /models, /usages
- Local Kimi CLI config: ~/.kimi/config.toml
- Filesystem: _auths directory + KMI_STATE_DIR

Internal Component Communication
- CLI -> core modules via direct calls
- Proxy -> state/logging/trace through shared State object

## 10. OPERATIONAL CONSIDERATIONS
- Logging: JSON logs to ~/.kmi/logs/kmi.log
- Rate limiting: proxy_max_rps/proxy_max_rpm
- Retries: proxy_retry_max + exponential backoff
- Health scoring combines usage + error telemetry

## 11. VERSION CONTROL INSIGHTS
- Branch: master
- Recent commits: 11 commits present (P4 fixes/tests/docs)
- Uncommitted changes: 28 untracked files in working tree
- CI/CD: no workflow files detected

## 12. EVOLUTION PATH & RECOMMENDATIONS
- Add .env.example and README install/run steps.
- Add CI workflow for pytest to prevent regressions.
- Add mypy/ruff for type and lint consistency.
- Add packaging notes for distribution (pipx or standalone).
- Consider pluggable upstreams for non-Kimi providers.

## 13. CRITICAL FINDINGS & RISKS
- Many untracked files: risk of missing changes in version control.
- No CI config: tests rely on manual execution.
- Remote proxy use is guarded, but TLS and network exposure remain an operational concern.

Peter's Honest Opinion
*Leans back in chair* This is not a ball of yarn; it's more like a disciplined cat: compact, purposeful, and occasionally sharp around the edges. Keep it fed with tests and it will behave.

## QUICK REFERENCE
Key Files and Locations
- Entry Point: src/kmi_manager_cli/cli.py
- Configuration: src/kmi_manager_cli/config.py
- Core Business Logic: src/kmi_manager_cli/rotation.py
- Proxy: src/kmi_manager_cli/proxy.py
- State/Trace: src/kmi_manager_cli/state.py, src/kmi_manager_cli/trace.py
- Documentation: docs/sdd/kmi-rotation-sdd/

Common Development Tasks
- Run Locally: kmi --help
- Run Tests: pytest
- Run Proxy: kmi proxy

PETER'S FINAL THOUGHTS
*Adjusts glasses* This codebase is a small but sturdy cat tree: it supports the core routines of rotation, proxying, and traceability. The paths are clear, the contracts are readable, and the behavior is predictable. Keep the guardrails (ToS, rate limits, and state safety) and it should stay calm even when the cats start sprinting at 2am.
