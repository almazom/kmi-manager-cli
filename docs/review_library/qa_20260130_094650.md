# QA Guardian Report
Suggested filename: docs/review_library/qa_20260130_094650.md

I bring 30 years of QA automation experience spanning CLI tooling, API proxies, and key-management workflows in production environments. Over three decades, I have built and audited test suites that serve as living documentation and prevent regressions under real-world load. That background shapes this review: prioritize behavioral contracts, edge cases, and failure modes that most often break operator trust. I focus on fast, reliable tests that guard core workflows without slowing iteration.

## Key Test Gaps (to verify/close)
- Proxy auth and remote binding guardrails: negative tests for missing token, non-local bind, and allowlist enforcement.
- Rotation edge cases: all keys disabled/exhausted, cooldown overlaps, mixed health signals, and "no eligible keys" behaviors.
- Health/usage parsing variance: payload shape drift, missing fields, auth failure vs. network error handling, and dry-run signaling.
- State/trace persistence: file locking/atomic writes, trace rotation limits, and permission warnings for insecure paths.
- CLI contract coverage: config precedence, help/flags interactions, and failure exit codes for invalid configs.

## Recommended Tests
- Unit: rotation selection (`select_key_for_request`, `rotate_manual`), health parsing (`_parse_limits`, `_extract_usage_summary`), config allowlist/URL validation, trace rotation boundaries.
- Integration: FastAPI proxy with TestClient + httpx mocks (timeouts, 429/5xx, retry/backoff), state persistence under concurrent requests, rate-limit buckets.
- E2E: Typer CLI flows (`kmi proxy`, `kmi health`, `kmi rotate auto/off`) validating stdout/stderr + exit codes; include dry-run vs real-run indicators.
- Contract: usage endpoint schema fixtures for multiple providers (golden JSONs) to detect upstream drift.

## Notes
- CI config not detected in repo root (no `.github` found). Consider adding a basic pytest workflow as a quality gate.
- No test execution performed in this pass; recommend `pytest` as a quick verification step.
