# Zombie Code Hunter Report
Suggested filename: docs/review_library/zombie_20260130_093623.md

I have spent about 30 years doing post-incident forensics and production hardening, so my "Zombie Code Hunter" instinct is to hunt the failures that only show up under stress or at 2 a.m. I have shipped and maintained CLI tools, proxies, and auth/rotation systems across startups and big enterprises, and I have seen the same classes of hidden brittleness repeat. My bias is toward pinpointing high-impact failure modes and the "silent losses" that hide until it is too late. I aim to be practical: flag the risky edges, then give you a path to make them boring and reliable.

## Findings
- Critical: Global rate limiting is effectively broken; `RateLimiter.allow()` never returns for non-zero limits, so enabling proxy rate limits will 429 every request, and there is dead/unreachable limiter code that looks like a copy/paste slip. `src/kmi_manager_cli/proxy.py:114`, `src/kmi_manager_cli/proxy.py:133`.
- High: "Dry-run" mode still performs live usage calls because health views force real requests, which can burn quota unexpectedly. `src/kmi_manager_cli/cli.py:173`, `src/kmi_manager_cli/cli.py:235`.
- High: Proxy forwards almost all headers and buffers full request/response bodies; without hop-by-hop header filtering or streaming, this is vulnerable to header-smuggling edge cases and memory spikes on large payloads. `src/kmi_manager_cli/proxy.py:276`, `src/kmi_manager_cli/proxy.py:322`.
- Medium: File locking is a no-op on Windows (fcntl missing), so concurrent runs can corrupt `state.json`/`trace.jsonl`/logs if multiple sessions occur. `src/kmi_manager_cli/locking.py:8`, `src/kmi_manager_cli/state.py:63`, `src/kmi_manager_cli/trace.py:53`.
- Medium: Observability is lossy and potentially sensitive: trace entries are dropped when the queue is full, and traces/logs/state are written as plaintext JSON with only a warning on permissive permissions (includes key labels/hash and endpoints). `src/kmi_manager_cli/proxy.py:80`, `src/kmi_manager_cli/trace.py:53`, `src/kmi_manager_cli/logging.py:32`, `src/kmi_manager_cli/state.py:37`.
- Low: Dependency ranges are open-ended (>= only) and there is no lockfile, which invites unreviewed upgrades or CVE drift and makes issues harder to reproduce. `pyproject.toml:14`.

## Assumptions / Questions
- Is Windows a supported target? If yes, we should harden locking or enforce single-instance usage.
- Is the intent for health views to ignore dry-run and always call upstream? If not, align them and add a "force live" flag.
- Should the proxy be safe for large payloads and untrusted clients? If so, streaming plus hop-by-hop header filtering becomes a priority fix.

## Change Summary
No code changes were made.
