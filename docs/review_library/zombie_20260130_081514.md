# Zombie Code Hunter Report — KMI Manager CLI (2026-01-30 08:15:14)

I have spent three decades digging through brittle systems where the failures only show up under real pressure. My instinct is to hunt for the quiet risks: version drift, silent security gaps, and the small shortcuts that become outages at scale. I read code the way incident responders read timelines — looking for the moment where trust is assumed instead of earned. If it can break without warning or leak without logging, I treat it as a ticking fuse.

## High-Risk Findings

1) Dependency drift and outdated-library exposure (project-wide)
- Evidence: `pyproject.toml` uses only lower bounds (e.g., `fastapi>=0.110.0`, `httpx>=0.26.0`, `typer>=0.12.0`) and no lock/constraints file is present.
- Risk: Environments can silently run very old versions (if pinned elsewhere) or jump to breaking changes (if freshly resolved). This is the most common “invisible regression” vector and makes security patching unpredictable.

2) Proxy can be exposed without transport security (remote use)
- Evidence: `src/kmi_manager_cli/proxy.py` allows remote binding when `KMI_PROXY_ALLOW_REMOTE=1` and requires only a static token; no TLS termination or mTLS support is present.
- Risk: If run on a LAN/WAN, bearer token and upstream request/response metadata can be sniffed or replayed. This is a confidentiality risk for API usage and potentially for the upstream key pool.

3) Weak config parsing (custom TOML parser)
- Evidence: `src/kmi_manager_cli/auth_accounts.py` implements `_parse_toml` via regex and string splitting.
- Risk: Any non-trivial TOML (inline comments, multiline strings, arrays, nested tables) can be misread or silently ignored, which can select the wrong provider or fail to load keys. This is a classic hidden fragility that manifests as “missing keys” or unexpected routing.

4) File locking is best-effort only (cross-process state corruption)
- Evidence: `src/kmi_manager_cli/locking.py` uses `fcntl` when available, but on platforms without it (e.g., Windows) it becomes a no-op. Trace writes are not atomic; state writes are atomic but rely on the lock file.
- Risk: Running multiple CLI processes or a proxy plus health checks can corrupt `~/.kmi/state.json` or trace logs, causing rotation bugs or misleading health data.

## Medium-Risk Findings

5) No allowlist or scheme validation for upstream base URLs
- Evidence: `src/kmi_manager_cli/config.py` and `auth_accounts.py` accept `base_url` from config files without enforcing `https://` or an allowlist.
- Risk: A compromised auth file can redirect traffic (and keys) to a hostile endpoint. This is a local threat model, but still a data-exfiltration vector.

6) Proxy response handling can mis-handle compressed payloads
- Evidence: `src/kmi_manager_cli/proxy.py` forwards `resp.content` and `resp.headers` from httpx directly.
- Risk: If httpx decompresses content but the original `content-encoding` header remains, clients may see corrupt payloads or double-decode errors. This is a subtle bug that appears with gzip or br responses.

7) In-memory rate limiting and state are not multi-process safe
- Evidence: `RateLimiter` and `State` are process-local; `uvicorn.run` uses a single process, but external execution with multiple workers is possible.
- Risk: Multi-worker deployment bypasses rate limits and produces inconsistent rotation decisions, leading to quota exhaustion or uneven key usage.

8) Health checks fail closed without diagnostics
- Evidence: `fetch_usage()` in `src/kmi_manager_cli/health.py` swallows all exceptions and returns `None`.
- Risk: Transient network errors downgrade health scoring with no actionable error signal, which can trigger unnecessary rotations or “warn” states.

## Low-Risk / Design Smells

9) Secrets live in plaintext config files
- Evidence: Auth files under `_auths/` and `~/.kimi/config.toml` are read as plaintext with no permission tightening.
- Risk: On multi-user systems, default umask may allow other users to read key material; a minor but avoidable exposure.

10) No request/response size limits in proxy
- Evidence: `proxy.py` reads full request bodies and upstream responses into memory.
- Risk: Large payloads can cause memory spikes or slowdowns.

## Recommendations (Prioritized)

1) Dependency hygiene: introduce a lock file or constraints (`pip-compile`, Poetry, uv, or `pip-tools`) and add a routine upgrade policy + CVE scan.
2) Harden proxy transport: require TLS termination for any non-local usage (even via reverse proxy), and consider rotating tokens or short-lived proxy credentials.
3) Replace TOML regex parsing with `tomllib` (Py 3.11+) or `tomli` for older versions to remove silent parsing errors.
4) Strengthen cross-process safety: add platform-appropriate file locks or use a lightweight embedded DB (SQLite) for state/trace.
5) Add base_url validation: enforce `https://` and optionally a host allowlist for Kimi endpoints.
6) Make health failures observable: log fetch errors or surface them in the UI.
7) Add streaming support or response size caps for proxy reliability.

## Notes

- This review is based on local source inspection: `src/kmi_manager_cli/*.py` and `pyproject.toml`.
- No runtime or dependency graph audit was performed; adding a lock file is the first step to make that practical.
