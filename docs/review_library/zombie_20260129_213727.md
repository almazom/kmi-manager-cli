# Zombie Code Hunter Risk Review (2026-01-29)

## Expert Bio
I have 30 years of experience shipping production systems across fintech, developer tooling, and infrastructure. I have led incident response, postmortems, and hardening programs for services processing billions of requests per day. My focus is on reliability, security boundaries, and operational safety under real-world concurrency. I specialize in finding failure modes that only show up under load, partial outages, and messy user inputs.

## Findings (ordered by severity)

### High
- **Runtime crash on `--health` when current account matches an auth entry.** `Account` is referenced but never imported, so the CLI raises a `NameError` when a match is found. This blocks the health view for the current key and is easy to hit in real usage. `src/kmi_manager_cli/cli.py:100`.
- **State persistence is not atomic and has no file locking.** `state.json` is read with no JSON error handling and written in-place. A crash or concurrent writes (proxy + CLI or multiple proxies) can corrupt the file and then cause all future runs to crash at load time. `src/kmi_manager_cli/state.py:54-82`.
- **Proxy has no authentication guard.** If the user binds `KMI_PROXY_LISTEN` to a non-local interface (or exposes the port), any client can use the upstream keys. This is a direct quota and security risk even in "trusted" networks. `src/kmi_manager_cli/proxy.py:53-148`.

### Medium
- **UI crash in `render_health_dashboard`.** `reset_line` is referenced but never defined; calling this function raises `NameError`. The function is imported by the CLI and may be used by downstream tooling. `src/kmi_manager_cli/ui.py:241-247`.
- **Upstream request failures are unhandled in the proxy.** Any `httpx` network error bubbles up as a 500 and skips `record_request`, `save_state`, and trace logging. This hides failures and leaves rotation state inconsistent with reality. `src/kmi_manager_cli/proxy.py:113-148`.
- **Health check can misclassify invalid keys as "warn."** `/usages` failures (including 401/403) return `None`, which `score_key` downgrades to `warn` instead of `blocked`. This allows invalid keys to be re-selected in manual rotation until a real proxy request records auth errors. `src/kmi_manager_cli/health.py:160-214`, `src/kmi_manager_cli/rotation.py:10-55`.
- **Trace/log handling is brittle under concurrency and scale.** Trace appends have no file lock, and the TUI rereads the entire `trace.jsonl` file every refresh. Under multiple writers or large files, this can drop events, corrupt lines, or freeze the TUI. `src/kmi_manager_cli/trace.py:24-39`, `src/kmi_manager_cli/trace_tui.py:39-47`, `src/kmi_manager_cli/logging.py:19-35`.

### Low
- **Direct script execution path misses CLI commands.** `if __name__ == "__main__": app()` runs before `proxy`, `trace`, and `rotate` commands are registered. Running the module as a script results in an incomplete CLI. `src/kmi_manager_cli/cli.py:149-196`.
- **Custom TOML parsing is fragile.** The hand-rolled parser ignores single-quoted strings and inline comments, and may misparse `~/.kimi/config.toml` when standard TOML features are used. This can silently skip valid API keys or base URLs. `src/kmi_manager_cli/auth_accounts.py:33-93`.
- **Testing gaps (risk of regressions).** No tests cover `--health` mapping, `render_health_dashboard`, corrupted `state.json` recovery, concurrent state writes, or proxy upstream failure handling. These are the same paths most likely to fail in production.

## Open Questions / Assumptions
- Is the proxy intended to be strictly local-only? If so, should it enforce `127.0.0.1`/`localhost` by default or require an explicit allowlist/token when binding to non-local interfaces?
- Is multi-process usage (proxy + CLI at the same time, or multiple proxies) a supported scenario? If yes, state/trace/log locking is required.
- Should `/usages` errors (401/403) be treated as "blocked" to prevent manual rotation from picking invalid keys?

## Change Summary
- No code changes made. This report documents current technical risk and potential fixes.
