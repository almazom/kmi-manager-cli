# Technical Risk Review - KMI Manager CLI (2026-01-29)

## Analyst Note (Zombie Code Hunter)
I have 30 years of experience tracking the quiet failures that only show up in production, and I approach this codebase like a forensics scene rather than a demo. I focus on where time, concurrency, and misconfiguration intersect, because that is where systems tend to rot. My bias is toward finding survivability gaps (locks, retries, state drift, and secrets hygiene) before they become outages. I am comfortable being the person who ruins the happy path to protect the long tail.

## Scope
Review focuses on technical risk: outdated libraries/platform, security posture, legacy/dead code, and hidden failure modes. Code reviewed in `src/kmi_manager_cli` plus project config in `pyproject.toml`.

## High-Risk Findings
- **Platform EOL risk (Python 3.8 minimum)**: The project allows Python 3.8+, but Python 3.8 reached end-of-life in October 2024. Environments still pinned to 3.8 will no longer receive security fixes, which is a direct operational risk for a network-exposed proxy.
- **Cross-process state corruption risk**: State is persisted via `state.json` with file locks that depend on `fcntl`. On platforms without `fcntl` (notably Windows), the lock becomes a no-op, allowing concurrent writes that can corrupt state/trace files. Even on Linux, multiple proxy processes or workers will each keep in-memory state and overwrite one another, losing counters and rotation indexes.
- **Proxy exposure without transport security**: When bound remotely, the proxy relies on a static bearer token but does not enforce TLS. A token sent over plaintext HTTP is trivially captured on hostile networks, leading to full key proxy access.

## Medium-Risk Findings
- **Dependency drift and compatibility risk**: Dependencies are specified only with lower bounds (e.g., `fastapi>=0.110.0`, `httpx>=0.26.0`). This permits unbounded upgrades, which can introduce breaking changes or security regressions without any version pinning strategy.
- **Permanent key disablement from transient 401/403**: Any 401/403 response increments counters that mark keys as blocked forever (`_is_eligible`), with no automatic recovery. If a transient 401/403 occurs (proxy upstream outage, partial auth glitch), that key stays dead until manual intervention.
- **Retry strategy can amplify upstream harm**: Retries are per-request and exponential, but there is no jitter and no global circuit breaker. Under upstream degradation, multiple concurrent requests can synchronize retries and create bursty traffic patterns.

## Security Observations
- **Secrets at rest**: API keys are stored in plaintext files (`_auths` and `~/.kimi/config.toml`). Logs and traces store metadata (key labels, key hashes, endpoints). This is likely acceptable for a local CLI but should be called out explicitly as a risk if users operate on shared machines.
- **Header pass-through**: The proxy forwards most client headers upstream (minus host/content-length). If clients send sensitive internal headers, they can leak to the upstream by default.

## Legacy or Dead Code Signals
- **Dual packaging shims**: There is a `sitecustomize.py` and a root-level `kmi_manager_cli/__init__.py` to make local imports work without installation. This is not necessarily wrong, but it is a sign of a legacy dev convenience layer that can mask packaging issues and diverge from installed behavior.
- **Docs split (`Docs/` vs `docs/`)**: Two documentation roots suggest historic migration or duplication. That split increases the chance of stale instructions and hard-to-follow operational guidance.

## Hidden Failure Modes
- **State drift under concurrency**: `state.json` is loaded once at startup and then mutated in memory. If multiple proxy instances run, each will overwrite the state with stale counters, causing rotation behavior to drift and stats to become unreliable.
- **Trace file growth unbounded**: Trace is appended indefinitely with no retention/rotation. Long-lived processes will produce very large `trace.jsonl` files, slowing TUI rendering and potentially filling disks.
- **Simplistic config parsing**: The custom TOML parser in `auth_accounts.py` is intentionally minimal and may ignore legitimate TOML features. It can silently fail to load keys if the config format evolves or uses syntax not handled by the regex parser.

## Recommendations (Short-Term)
- Pin supported Python to 3.9+ (or 3.10+) and document the supported range explicitly.
- Add a state store strategy for multi-process use (e.g., file-level locks that work on Windows, or move to SQLite).
- Add a clear warning when binding to non-localhost without TLS; optionally support `--proxy-tls` or document reverse-proxy TLS.
- Introduce dependency upper bounds or a lockfile for release builds.
- Add retention controls for trace and logs (size or time based).

## Recommendations (Longer-Term)
- Replace ad-hoc TOML parsing with a proper TOML parser to avoid silent config dropouts.
- Add a bounded retry + circuit breaker policy to reduce upstream amplification under failure.
- Provide a key health reset mechanism or decay policy to recover from transient auth errors.

## Notable Strengths (Risk Reducers)
- Keys are masked in UI output, reducing accidental leakage.
- File writes are atomic and use a lock file on platforms where `fcntl` exists.
- Proxy has explicit opt-in for remote binding and requires a token when remote.

