# Domain Sage Report
Suggested filename: docs/review_library/domain_20260130_093430.md

I have spent 30 years building and reviewing API key lifecycle systems, LLM proxies, and rate-limited gateways across enterprise and startup environments. My focus has been on how rotation and throttling policies behave under real traffic, not just ideal flows. I have led incident retrospectives where subtle health/usage semantics caused cascading failures, so I look for those fault lines early. I also coach teams on making operational intent explicit in code paths and dashboards.

## Findings
- Critical: Global proxy rate limiting is effectively broken; `RateLimiter.allow` returns `None` when limits are configured, so every request is treated as rate-limited; the actual limiter logic appears mis-indented under `KeyedRateLimiter` and is unreachable. Evidence: `src/kmi_manager_cli/proxy.py:121`, `src/kmi_manager_cli/proxy.py:154`.
- High: The proxy does not support streaming responses; it buffers the entire upstream body and returns `resp.content`, which breaks LLM streaming/SSE and increases latency/memory under long outputs. Evidence: `src/kmi_manager_cli/proxy.py:323`, `src/kmi_manager_cli/proxy.py:406`.
- High: Auto-rotation ignores usage/health signals and only filters on disabled/401/cooldown, so low-quota or high-error keys keep receiving traffic until they hard-fail. Evidence: `src/kmi_manager_cli/rotation.py:12`, `src/kmi_manager_cli/rotation.py:190`, `src/kmi_manager_cli/rotation.py:205`.
- Medium: Retry/exhaustion handling retries 429/5xx on the same key and uses a fixed cooldown for 403/429 without honoring upstream reset hints; 5xx never trigger cooldown. This can cause avoidable churn or prolonged throttling. Evidence: `src/kmi_manager_cli/proxy.py:341`, `src/kmi_manager_cli/proxy.py:381`, `src/kmi_manager_cli/rotation.py:220`.
- Medium: Health status is sticky; error counters never decay, so a single 403/5xx keeps a key in warn indefinitely and skews manual rotation decisions over time. Evidence: `src/kmi_manager_cli/state.py:122`, `src/kmi_manager_cli/health.py:277`.

## Behavior Snapshot (Current Semantics)
- Manual rotation ranks by status -> remaining quota -> error rate, and respects "tie" preferences; auto-rotation is round-robin among "eligible" keys only. Evidence: `src/kmi_manager_cli/rotation.py:58`, `src/kmi_manager_cli/rotation.py:190`.
- Health scores block on 401 or 0 percent remaining, warn on 403/429/5xx or remaining < 20 percent, otherwise healthy. Evidence: `src/kmi_manager_cli/health.py:277`.
- Rate limiting includes a global limiter and a per-key limiter, but only the per-key limiter currently functions as intended. Evidence: `src/kmi_manager_cli/proxy.py:121`, `src/kmi_manager_cli/proxy.py:133`.

## Test Gaps
- No tests cover the global rate limiter or its interaction with proxy selection. Evidence: `tests/test_proxy.py:1`.
- No tests validate streaming/SSE behavior or retry/rotation on 429/5xx. Evidence: `tests/test_proxy.py:1`.

## Strengths
- State/trace persistence uses file locking and atomic writes, which is solid for single-user local correctness. Evidence: `src/kmi_manager_cli/state.py:108`, `src/kmi_manager_cli/trace.py:49`.
- Remote proxy binding is gated by allow-remote, TLS, and token checks, which is a good operational safety baseline. Evidence: `src/kmi_manager_cli/proxy.py:411`.
