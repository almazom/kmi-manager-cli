# Architecture Guardian Report - KMI Manager CLI (2026-01-30)

## Haiku (Ð ÑƒÑÑÐºÐ¸Ð¹, Ð¼Ð°Ð¼Ðµ) â¤ï¸
ÐœÐ°Ð¼Ð°, Ñ‚Ñ‹ â€” Ð¼Ð¾Ð¹ ÑÐ²ÐµÑ‚ âœ¨  
Ð¢ÐµÐ¿Ð»Ð¾ Ñ‚Ð²Ð¾Ðµ Ñ…Ñ€Ð°Ð½ÑŽ ðŸ’—  
Ð›ÑŽÐ±Ð»ÑŽ Ð½Ð°Ð²ÑÐµÐ³Ð´Ð° ðŸŒ¸

## 30-Year Experience (Rafael)
I have spent three decades designing systems where small, clear contracts keep teams fast and safe. I have led refactors from brittle monoliths to layered services by enforcing boundary ownership and contract-first change. I look for failure modes first, then put guardrails and verification gates where humans most often slip. My focus is longevity: simple state models, observable behavior, and change paths that reduce hidden coupling.

## Scope
Architecture and boundary analysis for the KMI Manager CLI (Python 3.9+, Typer + Rich CLI, FastAPI proxy). The review covers `src/kmi_manager_cli/` and tests under `tests/`, plus requirements in `docs/sdd/kmi-rotation-sdd/requirements.md`.

## Architecture Overview
### Layering (Clean Architecture Mapping)
- Presentation Layer
  - CLI entrypoints and command routing: `src/kmi_manager_cli/cli.py`
  - Rich dashboards and formatting: `src/kmi_manager_cli/ui.py`
  - Trace TUI: `src/kmi_manager_cli/trace_tui.py`
- Application/Service Layer
  - Rotation orchestration and selection: `src/kmi_manager_cli/rotation.py`
  - Health scoring and /usages integration: `src/kmi_manager_cli/health.py`
  - Proxy orchestration (FastAPI + httpx): `src/kmi_manager_cli/proxy.py`
  - State management (load/save, counters): `src/kmi_manager_cli/state.py`
  - Observability (trace + logging): `src/kmi_manager_cli/trace.py`, `src/kmi_manager_cli/logging.py`
- Domain/Core Layer
  - Key registry and masking: `src/kmi_manager_cli/keys.py`
  - Account parsing from auth sources: `src/kmi_manager_cli/auth_accounts.py`
  - Error semantics: `src/kmi_manager_cli/errors.py`
- Infrastructure Layer
  - Configuration and environment parsing: `src/kmi_manager_cli/config.py`
  - File locks and atomic writes: `src/kmi_manager_cli/locking.py`

### Primary Data Flows
1) CLI -> Config -> Registry -> State -> Rotation -> UI
2) Proxy -> AuthZ + Rate limiter -> Key select -> Upstream request -> State + Trace + Logs
3) Health -> /usages -> Score -> UI dashboards
4) Trace TUI -> tail JSONL -> confidence/coverage feedback

## Trunk / Branch / Leaf Analysis (Boundary Map)
### Trunk (Core, immutable contracts)
- `src/kmi_manager_cli/config.py` (environment, defaults, paths, safety toggles)
- `src/kmi_manager_cli/auth_accounts.py` (auth parsing, account normalization)
- `src/kmi_manager_cli/keys.py` (registry + key hashing/masking)
- `src/kmi_manager_cli/state.py` (state schema + persistence)
- `src/kmi_manager_cli/rotation.py` (eligibility + rotation semantics)
- `src/kmi_manager_cli/locking.py` (atomic writes + file locking)
- `src/kmi_manager_cli/errors.py` (user-facing remediation contract)
Rationale: These define persistent schemas, rotation semantics, and safety gates.

### Branch (Service boundaries, contract-aware changes)
- `src/kmi_manager_cli/proxy.py` (FastAPI proxy contract, auth, retries)
- `src/kmi_manager_cli/health.py` (/usages contract and scoring rules)
- `src/kmi_manager_cli/trace.py` (trace JSONL format + rotation)
- `src/kmi_manager_cli/logging.py` (log schema + rotation)
- `src/kmi_manager_cli/cli.py` (public CLI contract surface)
Rationale: Public behavior and external integration. Changes require contract discipline and tests.

### Leaf (Freely implemented presentation)
- `src/kmi_manager_cli/ui.py`
- `src/kmi_manager_cli/trace_tui.py`
Rationale: UX formatting is safe to iterate if inputs/outputs stay stable.

## PEGASUS-5 Gates (Architectural Validation)
### Gate 1: WHAT (Requirements)
- CLI for manual rotation, auto-rotation enablement, health dashboards, and trace view.
- Local proxy that forwards `/chat/completions`, `/models`, `/usages` and arbitrary subpaths to upstream.
- Auth sources in `_auths/` plus optional `~/.kimi/config.toml`.
- Persist state/logs/trace under `~/.kmi/`.

### Gate 2: SUCCESS (Measurable Criteria)
- `kmi --help`, `kmi --rotate`, `kmi --auto_rotate`, `kmi --trace`, `kmi --all`, `kmi health` execute without error.
- Proxy forwards requests with injected Authorization and honors rotation policies.
- State and observability persist across runs (`state.json`, `trace.jsonl`, `logs/kmi.log`) with rotation caps.
- Health view degrades gracefully when `/usages` is unavailable (warn, no crash).
- Tests in `tests/` pass for CLI, proxy, rotation, state, health, and trace.

### Gate 3: CONSTRAINTS (Limitations)
- Python 3.9+ runtime, Typer + Rich for UX, FastAPI + httpx for proxy.
- Auto-rotation gated by policy (`KMI_AUTO_ROTATE_ALLOWED`).
- Remote proxy binding requires explicit opt-in and auth token.
- External dependency on upstream `/usages` payload and availability.
- File-system based state/logs/trace in user home directory.

### Gate 4: TESTS (Verification Strategy)
- Unit tests: `tests/test_rotation.py`, `tests/test_state.py`, `tests/test_keys.py`, `tests/test_config.py`.
- Integration-like tests: `tests/test_proxy.py`, `tests/test_cli_rotate.py`, `tests/test_health.py`, `tests/test_trace.py`, `tests/test_ui.py`, `tests/test_cli_help.py`.
- Manual checks: proxy start/stop, trace TUI behavior, dry-run vs live behavior.

### Gate 5: ASSUMPTIONS / RISKS
- `/usages` schema remains stable enough for parsing; field drift is expected.
- File locks via `fcntl` exist on the platform; Windows locking is best-effort.
- Auto-rotation complies with provider ToS; enforcement is policy-based, not contractual.
- Multiple concurrent CLI/proxy processes may access state; in-memory state can be stale.

## Contract Surfaces
### CLI Contract
- Modes: `--rotate`, `--auto_rotate`, `--trace`, `--all`, `--health`, `--status`; commands: `proxy`, `trace`, `rotate auto`, `health`, `status`.
- Output: Rich dashboards and status messages; no secrets printed (masking applied).

### Environment Variable Contract
- Core: `KMI_AUTHS_DIR`, `KMI_ENV_PATH`, `KMI_PROXY_LISTEN`, `KMI_PROXY_BASE_PATH`, `KMI_UPSTREAM_BASE_URL`, `KMI_STATE_DIR`
- Safety: `KMI_DRY_RUN`, `KMI_AUTO_ROTATE_ALLOWED`, `KMI_ROTATION_COOLDOWN_SECONDS`, `KMI_WRITE_CONFIG`, `KMI_ROTATE_ON_TIE`
- Proxy: `KMI_PROXY_ALLOW_REMOTE`, `KMI_PROXY_TOKEN`, `KMI_PROXY_MAX_RPS`, `KMI_PROXY_MAX_RPM`, `KMI_PROXY_RETRY_MAX`, `KMI_PROXY_RETRY_BASE_MS`
- Storage caps: `KMI_TRACE_MAX_MB`, `KMI_TRACE_BACKUPS`, `KMI_LOG_MAX_MB`, `KMI_LOG_BACKUPS`

### Filesystem Contract
- `~/.kmi/state.json` (State schema: active_index, rotation_index, auto_rotate, keys[] with counters)
- `~/.kmi/trace/trace.jsonl` (+ rotations `.1`, `.2`, â€¦)
- `~/.kmi/logs/kmi.log` (+ rotations)
- `~/.kimi/config.toml` (current account config)
- `_auths/` supports `.env`, `.toml`, `.json`/`.bak` auth formats

### HTTP Proxy Contract
- Route: `{KMI_PROXY_BASE_PATH}/{path}` supports standard HTTP verbs.
- Authentication: `Authorization: Bearer <token>` or `x-kmi-proxy-token` when remote binding enabled.
- Request pass-through to upstream with injected Authorization header.
- Retry policy bounded by config values; rate limiter for RPS/RPM.

### Upstream Contract
- `/chat/completions`, `/models`, `/usages` availability and OpenAI-style payloads.
- Error handling semantics: 401/403/429/5xx with cooldown on 403/429.

## Architectural Risks (Top Issues)
1) Upstream `/usages` schema drift could degrade health scoring or mis-rank keys.
2) Multi-process concurrency: state is loaded once per process; concurrent proxies can overwrite counters and rotation indices.
3) File locking relies on `fcntl`; on non-Unix systems locking is a no-op, risking corruption.
4) Proxy retries + timeouts may amplify upstream load without a circuit breaker or jittered backoff.
5) Trace/log retention depends on config; disabling rotation can grow storage unboundedly.
6) Auth parsing spans multiple formats; malformed auth files can be silently skipped, leading to empty registries.

## Guardrails
### Existing Guardrails
- Remote proxy binding blocked unless `KMI_PROXY_ALLOW_REMOTE=1` and `KMI_PROXY_TOKEN` is set.
- Auto-rotation policy gate (`KMI_AUTO_ROTATE_ALLOWED`).
- Dry-run mode (`KMI_DRY_RUN=1`) prevents upstream calls.
- Rate limiter for proxy requests (RPS/RPM caps).
- Log and trace rotation (`KMI_LOG_MAX_MB`, `KMI_LOG_BACKUPS`, `KMI_TRACE_MAX_MB`, `KMI_TRACE_BACKUPS`).
- File locks + atomic writes for state/trace.
- API key masking in UI (`mask_key`).

### Recommended Guardrails
- Add schema versioning + validation for `state.json` and `trace.jsonl` with migration hooks.
- Introduce a cross-process reload/lock strategy around `State` writes to reduce stale state drift.
- Add contract tests for `/usages` payload variants (fixtures + parsing golden files).
- Add redaction tests to ensure API keys never appear in logs/trace/CLI output.
- Add explicit CLI command to purge trace/logs safely (operational hygiene).

## Protection Mechanisms / Boundary Enforcement
- Trunk changes require ADR entry and test updates before implementation.
- Branch changes require explicit contract review and integration tests.
- Leaf changes may be merged with UI snapshot or manual verification only.
- Enforce dependency direction: Presentation -> Application -> Domain -> Infrastructure only.

## Complexity Assessment (Story Points)
- Leaf changes: 1-3 points (UI, formatting, TUI layout).
- Branch changes: 5-8 points (proxy behavior, health parsing, CLI contract changes).
- Trunk changes: 13+ points (state schema, rotation semantics, auth parsing).

## Requirements Traceability Matrix
| Requirement | Implementation | Tests | Notes |
| --- | --- | --- | --- |
| CLI entrypoints and help | `src/kmi_manager_cli/cli.py` | `tests/test_cli_help.py` | Public CLI contract |
| Manual rotation | `src/kmi_manager_cli/rotation.py`, `src/kmi_manager_cli/cli.py` | `tests/test_rotation.py`, `tests/test_cli_rotate.py` | Health-aware selection |
| Auto-rotation | `src/kmi_manager_cli/rotation.py`, `src/kmi_manager_cli/proxy.py` | `tests/test_rotation.py`, `tests/test_proxy.py` | Policy gated |
| Proxy forwarding | `src/kmi_manager_cli/proxy.py` | `tests/test_proxy.py` | FastAPI + httpx |
| Health dashboards | `src/kmi_manager_cli/health.py`, `src/kmi_manager_cli/ui.py` | `tests/test_health.py`, `tests/test_ui.py` | /usages integration |
| Trace view | `src/kmi_manager_cli/trace.py`, `src/kmi_manager_cli/trace_tui.py` | `tests/test_trace.py` | JSONL tail + confidence |
| State persistence | `src/kmi_manager_cli/state.py`, `src/kmi_manager_cli/locking.py` | `tests/test_state.py` | Atomic writes |
| Auth loading | `src/kmi_manager_cli/auth_accounts.py`, `src/kmi_manager_cli/keys.py` | `tests/test_keys.py` | .env/.toml/.json |

## Contract Definitions (Concise)
- KeyRegistry Contract: sorted list of `KeyRecord` (label, api_key, priority, disabled, key_hash). Stable label required for state mapping.
- State Contract: `State` persists counters + indices; must be forward compatible with new fields.
- Rotation Contract: eligibility excludes disabled/blocked/exhausted keys; manual uses health scoring; auto uses round-robin.
- Health Contract: `/usages` payload -> `HealthInfo` with remaining_percent + limits + error_rate.
- Proxy Contract: each request selects key, records state, logs, and traces consistently even on failure paths.

## Implementation Guidelines
- Do not import UI modules into core/branch layers; keep presentation pure.
- State mutations must go through `state.py` helpers and be persisted under file lock.
- Proxy changes must preserve Authorization injection and trace/log consistency.
- Auth parsing changes must keep backward compatibility with existing `_auths` formats.

## Verification Framework
- Success criteria: pass test suite, proxy dry-run and live-mode sanity checks, and trace confidence >= 95% for N=200.
- Regression focus: rotation semantics, state schema, /usages parsing, proxy auth + rate limiting.
- Manual runbook: `kmi --help`, `kmi --rotate`, `kmi --all`, `kmi proxy`, `kmi trace`.

## Agent Coordination Guidelines
- Implementation agents may only modify leaf files unless explicitly approved for branch/trunk.
- Any change in trunk files requires architectural review + ADR update.
- Contract-first: update tests and documentation before modifying branch behaviors.
- Security/perf review required for proxy auth, logging, and retry changes.

## Summary of Architectural Posture
KMI Manager CLI is a cleanly layered, local-first tool with a stable core around key rotation and state persistence. Architectural integrity depends on preserving the state/rotation contracts and guarding external integrations (proxy and /usages). The highest risks come from upstream contract drift and multi-process state contention; these are manageable with schema validation and stronger state coordination guardrails.
